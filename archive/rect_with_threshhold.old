import cv2
import sys
import numpy as np

argv = sys.argv
# Load the image (replace 'your_image_path.jpg' with the actual path to the uploaded image)
# This reads the image file into a numpy array for processing.
image_path = 'output.png'
image = cv2.imread(image_path)
if image is None:
    raise ValueError(f"Image not found or unable to load at path: {image_path}")

# Print basic image info for debugging
print(f"Image loaded successfully. Shape: {image.shape} (height, width, channels)")

# Convert to grayscale
# Grayscale simplifies edge detection by reducing to one channel.
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
print("Converted to grayscale.")

# Apply Gaussian blur to reduce noise
# Blur helps smooth out minor variations that could create false edges.
blurred = cv2.GaussianBlur(gray, (5, 5), 0)
print("Applied Gaussian blur.")


## use thresh
# After Gaussian blur on gray...
# Skip Canny, do thresholding instead for dark regions
_, thresh = cv2.threshold(blurred, int(argv[1]), 255, cv2.THRESH_BINARY_INV)  # Invert: dark=255 (white), light=0; tweak 100 if too much/little

# Optional: dilate to connect gaps from glare (kernel size 5x5, once)
kernel = np.ones((5,5), np.uint8)
thresh = cv2.dilate(thresh, kernel, iterations=1)

# Now find contours on thresh (not edges)
contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Then sort and loop/filter as before...
# In the filter: up the min area to ~10000 if small junk slips in; lower mean threshold to <80 for grey screens

# Use Canny edge detection
# Lowered thresholds for more edges: low=30 detects weaker edges, high=100 caps stronger ones.

contours = sorted(contours, key=lambda c: cv2.boundingRect(c)[0])

## lets copy the original image "output.png" so that we can add the contours to it
img_copy = image.copy()

## now lets save these contours for debugging
for i, cnt in enumerate(contours):
    cv2.drawContours(img_copy, [cnt], 0, (0, 0, 255), 2)

cv2.imwrite("contours_"+argv[1]+".png", img_copy)
print("Saved contours image as 'contours_"+argv[1]+".png'.")

