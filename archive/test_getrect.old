import cv2
import numpy as np

# Load the image (replace 'your_image_path.jpg' with the actual path to the uploaded image)
image = cv2.imread('output.png')
if image is None:
    raise ValueError("Image not found or unable to load.")

# Convert to grayscale
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Apply Gaussian blur to reduce noise
blurred = cv2.GaussianBlur(gray, (5, 5), 0)

# Use Canny edge detection
edges = cv2.Canny(blurred, 50, 150)

# Find contours
contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Filter contours to find potential screen rectangles
screens = []
for contour in contours:
    # Approximate the contour to a polygon
    approx = cv2.approxPolyDP(contour, 0.02 * cv2.arcLength(contour, True), closed=True)
    
    # Check if it's a quadrilateral (4 sides) and has sufficient area
    if len(approx) == 4 and cv2.contourArea(contour) > 5000:  # Adjust area threshold as needed
        # Get bounding rectangle
        x, y, w, h = cv2.boundingRect(approx)
        
        # Filter by aspect ratio (screens are roughly rectangular, wider than tall)
        aspect_ratio = w / float(h)
        if 1.2 < aspect_ratio < 2.0:  # Adjust based on observed screen proportions
            screens.append((x, y, w, h))

# Sort screens by x-coordinate to order them left to right
screens.sort(key=lambda rect: rect[0])

# Draw bounding boxes on the image for visualization
output = image.copy()
for i, (x, y, w, h) in enumerate(screens):
    cv2.rectangle(output, (x, y), (x + w, y + h), (0, 255, 0), 2)
    cv2.putText(output, f"Screen {i+1}", (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (0, 255, 0), 2)

# Display or save the result
cv2.imshow('Detected Screens', output)
cv2.waitKey(0)
cv2.destroyAllWindows()

# Optionally save the output
# cv2.imwrite('detected_screens.jpg', output)

# Print the bounding boxes
print("Detected screen locations (x, y, width, height):")
for rect in screens:
    print(rect)
